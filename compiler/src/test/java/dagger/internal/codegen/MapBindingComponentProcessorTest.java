/*
 * Copyright (C) 2014 Google, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package dagger.internal.codegen;

import static com.google.testing.compile.JavaSourceSubjectFactory.javaSource;
import static com.google.testing.compile.JavaSourcesSubjectFactory.javaSources;
import static org.truth0.Truth.ASSERT;

import com.google.common.collect.ImmutableList;
import com.google.testing.compile.JavaFileObjects;

import javax.tools.JavaFileObject;

import org.junit.Ignore;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;


/**
 * TODO: Insert description here. (generated by houcy)
 */
@RunWith(JUnit4.class)
public class MapBindingComponentProcessorTest {
  @Test public void mapBindingsFramework() {
    JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
        "");
    JavaFileObject mapModuleTwoFile = JavaFileObjects.forSourceLines("test.MapModuleTwo",
        "");
    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
        "");
    ASSERT.about(javaSources())
        .that(ImmutableList.of(mapModuleOneFile, mapModuleTwoFile, componentFile))
        .processedWith(new ComponentProcessor())
        .compilesWithoutError();
  }
  
  @Ignore @Test public void mapBindingsWithEnumKey() {
    JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
        "package test;",
        "",
        "import static dagger.Provides.Type.MAP;",
        "",
        "import dagger.Module;",
        "import dagger.Provides;",

        "",
        "@Module",
        "final class MapModuleOne {",
        "  @Provides(type = MAP) @EnumKey(Admin) Handler provideAdminHandler() { return new AdminHandler(); }",
        "}");
    JavaFileObject mapModuleTwoFile = JavaFileObjects.forSourceLines("test.MapModuleTwo",
        "package test;",
        "",
        "import static dagger.Provides.Type.MAP;",
        "",
        "import dagger.Module;",
        "import dagger.Provides;",
        "",
        "@Module",
        "final class MapModuleTwo {",
        "  @Provides(type = MAP) @EnumKey(Login) Handler provideLoginHandler() { return new LoginHandler(); }",
        "}");
    JavaFileObject enumKeyFile = JavaFileObjects.forSourceLines("test.EnumKey", 
        "package test;",
        "",
        "@MapKey",
        "public @interface EnumKey {",
        "  enum PathEnum {",
        "    Admin(\"/admin\"),",
        "    Login(\"/login\");",
        "    private final String path;",
        "    PathEnum(String path) {",
        "      this.path = path;",
        "    }",
        "  }",
        "  PathEnum value();",
        "}");
    JavaFileObject enumKeyFileTwo = JavaFileObjects.forSourceLines("test.EnumKey", 
        "package test;",
        "",
        "@MapKey",
        "public @interface EnumKey {",
        "  PathEnum value();",  // Or Enum value(); using annotationMirror to obtain the concrete value, compile reflection
        "}");
    JavaFileObject pathEnumFile = JavaFileObjects.forSourceLines("test.pathEnumFile", 
        "package test:",
        "",
        "public enum PathEnum {",
        "    Admin(\"/admin\"),",
        "    Login(\"/login\");",
        "    private final String path;",
        "    PathEnum(String path) {",
        "      this.path = path;",
        "    }");
    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
        "package test;",
        "",
        "import dagger.Component;",
        "import java.util.Map;",
        "",
        "import javax.inject.Provider;",
        "",
        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
        "interface TestComponent {",
        "  Map<EnumKey.PathEnum, Provider<Handler>> dispatcher();",
        "}");
    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
        "test.Dagger_TestComponent",
        "package test;",
        "",
        "import dagger.internal.MapFactory;",
        "import java.util.Map;",
        "import javax.annotation.Generated;",
        "import javax.inject.Provider;",
        "",
        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
        "public final class Dagger_TestComponent implements TestComponent {",
        "  private final MapModuleOne mapModuleOne;",
        "  private final MapModuleTwo mapModuleTwo;",
        "  private final Provider<Map<EnumKey.PathEnum, Provider<Handler>>> mapOfEnumHandlerProvider;",
        "",
        "  public Dagger_TestComponent(MapModuleOne mapModuleOne, MapModuleTwo mapModuleTwo) {",
        "    if (mapModuleOne == null) {",
        "      throw new NullPointerException(\"mapModuleOne\");",
        "    }",
        "    this.mapModuleOne = mapModuleOne;",
        "    if (mapModuletwo == null) {",
        "      throw new NullPointerException(\"mapModuleTwo\");",
        "    }",
        "    this.mapModuleTwo = mapModuleTwo;",
        "    this.mapOfEnumHandlerProvider = MapFactoryFactory.build()",
        "        .put(Admin(\"/admin\"), new ProviderAdminHandlerFactory(mapModuleOne))",
        "        .put(Login(\"/login\"), new ProviderLoginHandlerFactory(mapModuleTwo));",
        "  }",
        "",
        "  @Override public Map<EnumKey.PathEnum, Provider<Handler>> dispatcher() {",
        //add if else to return map<k, v> or map<k, provider<v>> 
        "    return mapOfEnumHandlerProvider.get();",
        "  }",
        "}");
    ASSERT.about(javaSources())
        .that(ImmutableList.of(mapModuleOneFile, mapModuleTwoFile, enumKeyFile, componentFile))
        .processedWith(new ComponentProcessor())
        .compilesWithoutError()
        .and().generatesSources(generatedComponent);
  }
  
  @Ignore @Test public void mapBindingsWithStringKey() {
    JavaFileObject mapModuleOneFile = JavaFileObjects.forSourceLines("test.MapModuleOne",
        "package test;",
        "",
        "import static dagger.Provides.Type.MAP;",
        "",
        "import dagger.Module;",
        "import dagger.Provides;",

        "",
        "@Module",
        "final class MapModuleOne {",
        "  @Provides(type = MAP) @StringKey(\"admin\") Handler provideAdminHandler() { return new AdminHandler(); }",
        "}");
    JavaFileObject mapModuleTwoFile = JavaFileObjects.forSourceLines("test.MapModuleTwo",
        "package test;",
        "",
        "import static dagger.Provides.Type.MAP;",
        "",
        "import dagger.Module;",
        "import dagger.Provides;",
        "",
        "@Module",
        "final class MapModuleTwo {",
        "  @Provides(type = MAP) @StringKey(\"login\") Handler provideLoginHandler() { return new LoginHandler(); }",
        "}");
    JavaFileObject stringKeyFile = JavaFileObjects.forSourceLines("test.StringKey", 
        "package test;",
        "",
        "@MapKey",
        "public @interface StringKey {",
        "  String value();",
        "}");
    JavaFileObject componentFile = JavaFileObjects.forSourceLines("test.TestComponent",
        "package test;",
        "",
        "import dagger.Component;",
        "import java.util.Map;",
        "",
        "import javax.inject.Provider;",
        "",
        "@Component(modules = {MapModuleOne.class, MapModuleTwo.class})",
        "interface TestComponent {",
        "  Map<String, Provider<Handler>> dispatcher();",
        "}");
    JavaFileObject generatedComponent = JavaFileObjects.forSourceLines(
        "test.Dagger_TestComponent",
        "package test;",
        "",
        "import dagger.internal.MapFactory;",
        "import java.util.Map;",
        "import javax.annotation.Generated;",
        "import javax.inject.Provider;",
        "",
        "@Generated(\"dagger.internal.codegen.ComponentProcessor\")",
        "public final class Dagger_TestComponent implements TestComponent {",
        "  private final MapModuleOne mapModuleOne;",
        "  private final MapModuleTwo mapModuleTwo;",
        "  private final Provider<Map<EnumKey.PathEnum, Provider<Handler>>> mapOfStringHandlerProvider;",
        "",
        "  public Dagger_TestComponent(MapModuleOne mapModuleOne, MapModuleTwo mapModuleTwo) {",
        "    if (mapModuleOne == null) {",
        "      throw new NullPointerException(\"mapModuleOne\");",
        "    }",
        "    this.mapModuleOne = mapModuleOne;",
        "    if (mapModuletwo == null) {",
        "      throw new NullPointerException(\"mapModuleTwo\");",
        "    }",
        "    this.mapModuleTwo = mapModuleTwo;",
        "    this.mapOfStringHandlerProvider = MapFactoryFactory.build()",
        "        .put(\"admin\", new ProviderAdminHandlerFactory(mapModuleOne))",
        "        .put(\"login\", new ProviderLoginHandlerFactory(mapModuleTwo));",
        "  }",
        "",
        "  @Override public Map<String, Provider<Handler>> dispatcher() {",
        //add if else to return map<k, v> or map<k, provider<v>> 
        "    return mapOfStringHandlerProvider.get();",
        "  }",
        "}");
    ASSERT.about(javaSources())
        .that(ImmutableList.of(mapModuleOneFile, mapModuleTwoFile, stringKeyFile, componentFile))
        .processedWith(new ComponentProcessor())
        .compilesWithoutError()
        .and().generatesSources(generatedComponent);
  }
}
